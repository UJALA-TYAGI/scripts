func RunNamingTestsAcrossEndpoints(ctx *common.AtlasScenarioContext, logging *scenario_logging.ScenarioLogger) {
    config := GetScenarioConfig(ctx)
    raw := config.Get(scenario_vars.NamingEndpoint)

    urls, ok := raw.([]interface{})
    if !ok {
        logging.Error(fmt.Sprintf("‚ùå Failed to parse %q from config ‚Äî expected a list of URLs", scenario_vars.NamingEndpoint))
        return
    }

    for _, u := range urls {
        urlStr, ok := u.(string)
        if !ok {
            logging.Warn("‚ö†Ô∏è Skipping a non-string URL in naming-api-endpoint")
            continue
        }

        logging.Info(fmt.Sprintf("üîÅ Running Naming tests for: %s", urlStr))
        shared_state.SetSharedState(ctx, "activeNamingEndpoint", urlStr)

        registerNamingStepBindings(ctx, logging)
    }
}

func NamingSteps(ctx *common.AtlasScenarioContext, logging *scenario_logging.ScenarioLogger) {
    RunNamingTestsAcrossEndpoints(ctx, logging)
}
baseURL := shared_state.GetSharedState(ctx).Get("activeNamingEndpoint").(string)



func createRequest(vars ScenarioConfig, endpoint string, method string) ([]*http.Response, error) {
    raw := vars.Get(NamingEndpoint) // NamingEndpoint is a const string elsewhere
    urlsInterface, ok := raw.([]interface{})
    if !ok {
        return nil, fmt.Errorf("naming-api-endpoint is not a list")
    }

    var responses []*http.Response
    for _, u := range urlsInterface {
        baseURL, ok := u.(string)
        if !ok {
            return nil, fmt.Errorf("found non-string URL in naming-api-endpoint")
        }

        apiEndpoint := baseURL + endpoint
        req, err := http.NewRequest(method, apiEndpoint, nil)
        if err != nil {
            return nil, err
        }

        // add headers, tokens if needed

        client := &http.Client{}
        resp, err := client.Do(req)
        if err != nil {
            return nil, err
        }

        responses = append(responses, resp)
    }

    return responses, nil
}

